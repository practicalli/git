{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Practicalli Git","text":"<p>Practical guides to effective use of Git clients and command line to interact with local and remote repositories.</p> <p>Git is a distributed source control management system, encouraging experimentation and giving fast feedback</p>"},{"location":"#navigate-the-book","title":"Navigate the book","text":"<p>Use the mouse or built-in key bindings to navigate the pages of the book</p> <ul> <li>P , , : go to previous page</li> <li>N , . : go to next page</li> </ul> <p>Use the search box to quickly find a specific topic</p> <ul> <li>F , S , / : open search dialog</li> <li>Down , Up : select next / previous result</li> <li>Esc , Tab : close search dialog</li> <li>Enter : follow selected result</li> </ul>"},{"location":"#practicalli-resources","title":"Practicalli Resources","text":"<p> Practicalli Website  Practicalli YouTube channel</p>"},{"location":"#sponsor-practicalli","title":"Sponsor Practicalli","text":"<p>All sponsorship funds are used to support the continued development of  Practicalli series of books and videos, although most work is done at personal cost and time.</p> <p>Thanks to  Cognitect,  Nubank and a wide range of other  sponsors from the Clojure community for your continued support</p>"},{"location":"#creative-commons-license","title":"Creative commons license","text":"This work is licensed under a Creative Commons Attribution 4.0 ShareAlike License (including images &amp; stylesheets)."},{"location":"assets/images/social/","title":"Social Cards","text":"<p>Social Cards are visual previews of the website that are included when sending links via social media platforms.</p> <p>Material for MkDocs is configured to generate beautiful social cards automatically, using the colors, fonts and logos defined in <code>mkdocs.yml</code></p> <p>Generated images are stored in this directory.</p>"},{"location":"commits/","title":"Commits","text":""},{"location":"commits/amend/","title":"Amend","text":""},{"location":"commits/commit-often/","title":"Commit often","text":""},{"location":"commits/messages/","title":"Messages","text":""},{"location":"commits/squash/","title":"Squash","text":""},{"location":"commits/squashing-commits/","title":"Squash several Git commits into a single commit","text":"<p>This note shows how to merge an ugly feature branch with multiple dirty WIP commits back into the master as one pretty commit.</p>"},{"location":"commits/squashing-commits/#easy-mode-reset-your-feature-branch-to-the-master-state","title":"Easy mode: Reset your feature branch to the master state","text":"<p>The easiest way to turn multiple commits in a feature branch into a single commit is to reset the feature branch changes in the master and commit everything again.</p> <p>Note Switch to the master branch and make sure you are up to date.</p> <pre><code>git checkout master\ngit fetch # this may be necessary (depending on your git config) to receive updates on origin/master\ngit pull\n</code></pre> <p>Note Merge the feature branch into the master branch.</p> <pre><code>git merge feature_branch\n</code></pre> <p>Note Reset the master branch to origin's state.</p> <pre><code>git reset origin/master\n</code></pre> <p>Note Git now considers all changes as unstaged changes. We can add these changes as one commit. Adding . will also add untracked files.</p> <pre><code>git add --all\ngit commit\n</code></pre> <p>Note that this is not touching the feature branch at all. If you would merge the feature branch into the master again at a later stage all of its commits would reappear in the log.</p> <p>You may also do it the other way round (merging master into the branch and resetting to the master state) but this will destroy your commits in the feature branch, meaning you can not push it to origin.</p>"},{"location":"commits/squashing-commits/#hard-mode-squash-commits","title":"Hard mode: Squash commits","text":"<p>This method is harder than using the get reset method above. Also it doesn\u2019t work well if you merged the master into the feature branch previously (you\u2019ll need to resolve all conflicts again).</p> <p>What we are describing here will destroy commit history and can go wrong. For this reason, do the squashing on a separate branch:</p> <pre><code>git checkout -b squashed_feature\n</code></pre> <p>This way, if you screw up, you can go back to your original branch, make another branch for squashing and try again.</p> <p>To squash all commits since you branched away from master, do</p> <pre><code>git rebase -i master\n</code></pre> <p>Note that rebasing to the master does not work if you merged the master into your feature branch while you were working on the new feature. If you did this you will need to find the original branch point and call git rebase with a SHA1 revision.</p> <p>Your editor will open with a file like</p> <pre><code>pick fda59df commit 1\npick x536897 commit 2\npick c01a668 commit 3\n</code></pre> <p>Each line represents a commit (in chronological order, the latest commit will be at the bottom).</p> <p>To transform all these commits into a single one, change the file to this:</p> <pre><code>pick fda59df commit 1\nsquash x536897 commit 2\nsquash c01a668 commit 3\n</code></pre> <p>This means, you take the first commit, and squash the following onto it. If you remove a line, the corresponding commit is actually really lost. Don\u2019t bother changing the commit messages because they are ignored. After saving the squash settings, your editor will open once more to ask for a commit message for the squashed commit.</p> <p>You can now merge your feature as a single commit into the master:</p> <pre><code>git checkout master\ngit merge squashed_feature\n</code></pre>"},{"location":"git-log/","title":"Git log","text":""},{"location":"git-log/magit-git-log/","title":"Magit Git Log","text":"<p>In part one I showed how easy it is to version a project using Git from within Emacs, using the Magit package.  This time we look at the git log within Magit.</p> <p>Working with the log gives you a lot more detail about your changes, helps you compare local and remote repo commits.  All of which helps you understand when you should push your code. </p>"},{"location":"git-log/magit-git-log/#git-logs-with-magit","title":"Git logs with Magit","text":"<p>On the command line you can use git log to see your change history, although it can be a bit fiddly to set up git to give you a pretty view of those logs.  In Magit you can just get on a explore the logs</p> <p>Inside the Magit buffer, press l to show the log menu and then either l for the short for log or L for the long form of the log.</p> <p>l l - short log l L - long log</p> <p></p> <p>Figure 1:  l - the Magit log menu </p> <p>Selecting the short log details allows you to see more commits, but you only see the commit message and not the files that have changes.</p> <p>In the following examples both the remote (github repository) and local repository are at the same commit - e447b51.  So you can easily tell if there are any local commits you have not pushed to Github.</p> <p></p> <p>Figure 2:  l l - the Magit log short listing</p> <p>Selecting the long log output, l L, you see more details of each commit, including the files changed, author and timestamp.</p> <p></p> <p>Figure 3:  l L - the Magit log short listing </p> <p>To see the changes within a commit, move the cursor over a commit number in the log and press space.  This brings up another buffer which you can scroll through.  You don't even need to switch to this new buffer as if you keep pressing space it will scroll through the text of the change.</p> <p></p> <p>Figure 4:  l L space - use the log to see the changes in a commit</p>"},{"location":"git-log/magit-git-log/#comparing-commits-diff-with-magit","title":"Comparing Commits (diff) with Magit","text":"<p>In the following example, the local repository is ahead of the Github repository by one commit.  The magit log can be used to compare commits.</p> <p>Move the cursor over the first commit and press . (full stop).  Then put the cursor over the second commit and press =.</p> <p></p> <p>Figure 5:  l l . =  - compare two commits using the Magit short log</p> <p>To exit buffer that opened the diff, simply press q in the Magit buffer****.</p>"},{"location":"git-log/magit-git-log/#summary-of-magit-log","title":"Summary of Magit log","text":"<p>I tend to just use the short form of the log and compare commits every now and again.  If I havent pushed a few commits up to Github for a while, its a handy way to check if I should push and what I am pushing.</p> <p>Of course if I write good commit messages and commit often to my local repo, then its much easier to tell what I am pushing from the short log :)</p>"},{"location":"git-log/track-commits/","title":"Track commits","text":"<p>Git is a great developer tool for managing and sharing code.  Its really easy to get started with, especially with services such as Github and their excellent try.github.com website.  I quickly became comfortable with the basic developer cycle:   </p> <p>git init git status  git add filename git commit -m \"useful message\" git push ;; back to git status...</p> <p>To keep track of changes when you just have a local repository is easy with git status.</p>"},{"location":"git-log/track-commits/#git-log-for-tracking-multiple-repositories","title":"Git log for tracking multiple repositories","text":"<p>When you start sharing a remote repository then changes are distributed and developers start using git log to track changes across repositories.  The challenge with git log is that by default you have to scroll through a lot of text to see what is happening.  This gets a bit tedious really quickly.</p> <p>Luckily, the git log output is very configurable so its really easy to get a clearer picture.  The most useful options to git log include</p> <p>--abbrev-commit Only shows the last part of the very long commit name, the sha.</p> <p>--graph Show an ascii graph of the commit history, also known as the commit graph.</p> <p>--pretty=oneline or --oneline Print the output onto one line.  The one-line value is one of several built in formats to the --pretty option and in this case can be used as an option on its own.</p> <p>--decorate Show the branch and tag names relative to the commit history, essential if you want to keep track of which commit version your remote repositories are at.</p> <p>Putting all these options together you get a much simpler and easier to follow view of the commit history.</p> <p></p>"},{"location":"git-log/track-commits/#creating-git-aliases","title":"Creating git aliases","text":"<p>Rather than type git log and all these options each time (or scroll through your shell history), you can create a git alias as a shortcut for this long command line</p> <p>Create an alias called lg for git as follows:</p> <pre><code>git config --global alias.lg 'log --graph --oneline --decorate --abbrev-commit'\n</code></pre> <p>This will add the alias called lg to your  ~/.gitconfig file.  You could also edit this file directly and add aliases manually.</p> <pre><code>[alias]  \n    lg = log --graph --oneline --decorate --abbrev-commit\n</code></pre>"},{"location":"git-log/track-commits/#the-commit-graph","title":"The commit graph","text":"<p>Visualising the commit graph is my must-have tool when using git, I use it nearly as often as my most used command; git status.  The commit graph shows a history of commits and the position of repos in that history.  When there are branches, this is rendered as a tree-like structure and it is easy to see the relative status of your local and remote repositories attached to the project.</p> <p>Most common status in git is to have your local repository ahead of the remote masters in terms of commits, with HEAD pointing to you local repo. Its quite common to do a group of related commits locally before pushing then to a shared remote repo.  When the remote repo is behind your local repo, this is quite obvious from the commit graph, as its on an earlier commit version and therefore a different line of the graph.</p> <p>You can see when a push happens to a remote repository from your local repo, as the branch merges into the trunk.  When everything that has been committed locally has been pushed then you can see the remote branch at the same commit version as the local.</p> <p>In the situation where you have multiple repositories, for different stages of the development workflow (for example testing, staging, CI), the commit graph really makes the status of your different repositories really clear.  You can see at a glance the commit version each repo is on.  The commit graph also helps you understand which commits to push to which repos.  This is also invaluable when merging two longer running branches (should you get to that situation).</p>"},{"location":"git-log/track-commits/#designing-your-own-commit-graph","title":"Designing your own commit graph","text":"<p>In the next article I will cover how to create your own design for the git commit graph, creating several aliases for different levels of information   </p>"},{"location":"ignoring-files/","title":"Ignoring files","text":"<p>By telling git to ignore files that are not relvant to the project you can help keep your commits nice and clean.  For example, if you dont exclude compiled classes directory, then each time you compile your code someone could add those changes.</p> <p>Not only does this make the git repository bigger than it needs to be, it also makes it harder to see the relevant changes made for a particular commit.</p>"},{"location":"ignoring-files/global-ignore/","title":"Global Ignore","text":"<p>Lots of developers are using git, especially when working on projects together.  However there is not one single developer tool that every one uses, so there is potential for a lot of unwanted files to end up in your project.</p> <p>Rather than pollute the .gitignore file for the project with every development tool under the sun, its much more effective to add development tool specific files to your own global ignore file ~/.gitignore_global.</p>"},{"location":"ignoring-files/global-ignore/#creating-my-own-global-ignores","title":"Creating my own global ignores","text":"<p>In the ~/.gitconfig of my home directory I have a section called [core] where a global excludes file is defined</p> <p>[core]     excludesfile = /Users/jstevenson/.gitignore_global</p> <p>By adding file name patters to the .gitignore_global file for Emacs, I can add my own personal excludes without adding unnecessary stuff to each project I work on.  It also means its one less thing to remember when I am working with git projects. In the root of your home directory, simple create or update the file .gitignore_global with all the file names and patterns that relate to the tools you use.</p>"},{"location":"ignoring-files/global-ignore/#ignore-patterns","title":"Ignore patterns","text":"<p>To help you out, here are some ignore patterns for some of the most common developer tools.  There are lots of ignore patterns on the Git Ignore github repository</p> <p></p>"},{"location":"ignoring-files/global-ignore/#emacs-ignore-patterns","title":"Emacs ignore patterns","text":"<p>~ ## /.emacs.desktop /.emacs.desktop.lock .elc auto-save-list tramp .#*</p>"},{"location":"ignoring-files/global-ignore/#org-mode","title":"Org-mode","text":"<p>.org-id-locations *_archive</p>"},{"location":"ignoring-files/global-ignore/#vi-vim","title":"Vi / Vim","text":"<p>.*.s[a-w][a-z]</p> <p>*.un~</p> <p>Session.vim</p> <p>.netrwhist</p> <p>*~</p>"},{"location":"ignoring-files/global-ignore/#_1","title":"Global Ignore","text":""},{"location":"ignoring-files/global-ignore/#intellij-ignore-patterns","title":"IntelliJ ignore patterns","text":"<p>.iml .ipr *.iws .idea/  </p>"},{"location":"ignoring-files/global-ignore/#netbeans-ignore-patters","title":"Netbeans ignore patters","text":"<p>nbproject/private/ build/ nbbuild/ dist/ nbdist/ nbactions.xml nb-configuration.xml</p> <p></p>"},{"location":"ignoring-files/global-ignore/#eclipse-ignore-patters","title":"Eclipse ignore patters","text":"<p>.pydevproject  .project  .metadata  bin/  tmp/  tmp// .tmp  .bak  .swp  ~.nib  local.properties  .classpath  .settings/  .loadpath</p>"},{"location":"ignoring-files/global-ignore/#external-tool-builders","title":"External tool builders","text":"<p>.externalToolBuilders/</p>"},{"location":"ignoring-files/global-ignore/#locally-stored-eclipse-launch-configurations","title":"Locally stored \"Eclipse launch configurations\"","text":"<p>*.launch</p>"},{"location":"ignoring-files/global-ignore/#cdt-specific","title":"CDT-specific","text":"<p>.cproject</p>"},{"location":"ignoring-files/global-ignore/#pdt-specific","title":"PDT-specific","text":"<p>.buildpath</p>"},{"location":"install/","title":"Install Git","text":"<ul> <li>Git-scm install</li> <li>Homebrew</li> <li>Debian Linux</li> <li>Arch Linux</li> </ul>"},{"location":"install/configure/","title":"Configure Git Client","text":"<p>Kickstart your confituration by using Practicalli Dotfiles</p> <p>Clone Practicalli Dotfiles</p> <p>```shell git clone --origin practicalli https://github.com/practicalli/dotfiles.git</p> <p>```</p> <p>Git configuration - Practicalli dotfiles</p>"},{"location":"install/configure/#identity","title":"Identity","text":"<ul> <li>name</li> <li>email</li> <li>GitHub / GitLab</li> </ul>"},{"location":"install/configure/#conditional-configuration","title":"Conditional configuration","text":"<p>Keep your identity and configuration distinct between project, e.g. Open Source and commercial projects.</p>"},{"location":"install/ssh-keys/","title":"Secure Shell (SSH) Keys","text":"<p>Authenticate against remote services and servers using Secure Shell (SSH) key pairs.</p> <p>Create a public and private key pair and share the public key with the service or server.</p> <p>Use ED... algorithm</p>"},{"location":"introduction/git-cheatsheet/","title":"Git Cheat Sheet","text":"<p>There are many Git Cheat Sheets to choose from, mostly as a PDF.</p> <p>Git Cheat Sheet - GitHub Education (PDF)</p> <p>Git Cheat Sheet - Atlassian (PDF Download)</p> <p>GitHub Training Kit - GitHub - multi-lingual (PDF)</p> <p>Git Cheat Sheet - GitLab (PDF)</p> <p>Cheat Sheet - freeCodeCamp</p>"},{"location":"introduction/git-cheatsheet/#general-learning-resources","title":"General learning resources","text":"<p>Git &amp; GitHub learning resources</p>"},{"location":"introduction/git-workflow/","title":"Git Workflow","text":"<p>Simple as possible but no simpler</p> <p>Work in progress</p>"},{"location":"introduction/git-workflow/#single-branch","title":"single branch","text":"<p>Push everything to main</p> <p>Communicate what is being worked on</p> <p>Rebase by default</p> <p>Configure git client to use <code>--rebase</code> by default when pulling changes</p> <p>Become comfortable with merge tools (although conflicts should be minimised if contributers are communicating well)</p>"},{"location":"introduction/git-workflow/#shared-repositories","title":"Shared repositories","text":"<p>Avoid changing history by default</p> <p>Communicate history changes if they occur</p>"},{"location":"introduction/git-workflow/#github-flow","title":"GitHub flow","text":"<p>Pull Request driven workflow</p> <p>Context: - open source projects - disparate team locations</p> Gitflow workflow <p>If there is a need to work across multiple shared branches, then Gitflow is an interesting strategy.</p> <p>Only adopt this flow if there is considerable value using multiple branches rather than simplifying your flow.</p> <p> Gitflow workflow - Atlassian</p>"},{"location":"introduction/git-workflow/#references","title":"References","text":"<p> Collaborating workflows - Atlassian</p> <p> Comparing Git Workflows - Atlassian</p>"},{"location":"rebasing/","title":"local repositories","text":""},{"location":"staging/","title":"Using Stages","text":"<p>There are several stages in Git you can manage changes with, so lets make the most of them.  The stages are:</p> <ul> <li>Stash</li> <li>Working Copy</li> <li>Index / Staging</li> <li>Local Repository</li> <li>Shared Repositories </li> </ul> <p></p> <p>Using Stash, Working Copy &amp; </p>"},{"location":"staging/interactive-staging/","title":"Interactive staging","text":"<p>While you can use <code>git diff</code> to see what changes you have to stage, if there are many then using <code>git add</code> in an interactive mode will let you step through each change, one by one.</p> <pre><code>git add -p \n\ngit add -p filename\n</code></pre>"},{"location":"staging/interactive-staging/#hunks","title":"Hunks","text":"<p>Git groups changes into a fairly logical grouping called a Hunk.</p> <p>When you are interactively adding changes, git shows you the next hunk and asks if you wan to add or skip it.  Sometimes a hunk contains more changes line that you want to include, so you can split the hunk.</p>"},{"location":"staging/use-git-diff/","title":"Use git diff","text":"<p>The <code>git diff</code> command will show you which lines have changed, comparing the working copy with the commits in the local repository.  You can also just show the changes for a particular file.</p> <pre><code>git diff \n\ngit diff filename\n</code></pre> <p>You can see more specific changes</p> <pre><code>git diff --word-diff\n\ngit diff --word-diff filename\n</code></pre> <p>This will show you the specific words on each line that have changed.  This is really good for picking up small changes, so its worth adding an alias for this to your git configuration, <code>~/.gitconfig</code></p>"},{"location":"staging/use-git-diff/#comparing-the-index","title":"Comparing the Index","text":"<p>The <code>git diff</code> command also has an option for comparing the Index with the commits in the local repository.  This is a very useful tool to run before you create a new commit, to help check that you have added all the changes you want and none that you do not.</p> <pre><code>git diff --cached\n\ngit diff --cached filename \n</code></pre>"},{"location":"staging/use-the-index/","title":"Use the Index","text":"<p>It can be tempting to just commit all using <code>git commit -am \"Commit all the things\"</code>, however there can be lots of changes that you dont want to include.</p> <p>When you are busy it is easy to forget changes you made that are not relevant.  A good approach is to consider a stage every time you save the file you are working on.</p> <pre><code>git add filenames\n</code></pre> <p>You can add the same filename over and over again as you create more changes in your editor.</p>"},{"location":"staging/use-the-index/#adding-changes-to-the-index-are-easy-to-undo","title":"Adding changes to the Index are easy to undo","text":"<p>Its very easy to remove a change from staging</p> <pre><code>git reset HEAD filenames\n</code></pre> <p>As all this command does is unstage the file (or files) from the index, then there is very little impact.  Your editor most likely has all this information in its history.</p>"}]}